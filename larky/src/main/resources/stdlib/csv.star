# -*- coding: utf-8 -*-
"""A port of Python 3's csv module to Larky.

This is a Larky translation of PyPI package backports.csv located here:
 - https://github.com/ryanhiebert/backports.csv/blob/master/src/backports/csv.py

The so-called CSV (Comma Separated Values) format is the most common import and
export format for spreadsheets and databases. CSV format was used for many years
prior to attempts to describe the format in a standardized way in RFC 4180. The
lack of a well-defined standard means that subtle differences often exist in the
data produced and consumed by different applications. These differences can make
it annoying to process CSV files from multiple sources. Still, while the
delimiters and quoting characters vary, the overall format is similar enough
that it is possible to write a single module which can efficiently manipulate
such data, hiding the details of reading and writing the data from the
programmer.

The csv module implements classes to read and write tabular data in CSV format.
It allows programmers to say, “write this data in the format preferred by
Excel,” or “read data from this file which was generated by Excel,” without
knowing the precise details of the CSV format used by Excel. Programmers can
also describe the CSV formats understood by other applications or define their
own special-purpose CSV formats.

The csv module’s reader and writer objects read and write sequences. Programmers
can also read and write data in dictionary form using the DictReader and
DictWriter classes.
"""
load("@stdlib//builtins", builtins="builtins")
load("@stdlib//io/StringIO", StringIO="StringIO")
load("@stdlib//larky", WHILE_LOOP_EMULATION_ITERATION="WHILE_LOOP_EMULATION_ITERATION", larky="larky")
load("@stdlib//operator", operator="operator")
load("@stdlib//re", re="re")
load("@stdlib//types", types="types")
load("@vendor//option/result", Error="Error", Result="Result", safe="safe")

QUOTE_MINIMAL, QUOTE_ALL, QUOTE_NONNUMERIC, QUOTE_NONE = range(4)
_dialects = {}

map = builtins.map
string_types = str
text_type = str
binary_type = bytes


undefined = larky.SENTINEL
_field_limit = [128 * 1024] # max parsed field size

def field_size_limit(limit=undefined):
    """Sets an upper limit on parsed fields.
    csv.field_size_limit([limit])
    Returns old limit. If limit is not given, no new limit is set and
    the old limit is returned"""

    old_limit = _field_limit[0]

    if limit != undefined:
        if not types.is_int(limit):
            return Error("TypeError: int expected, got %s"
                         % type(limit)).unwrap()

        _field_limit[0] = limit

    return old_limit


def QuoteStrategy(dialect):

    self = larky.mutablestruct(__name__='QuoteStrategy', __class__=QuoteStrategy)
    self.quoting = None

    def setup():
        """Optional method for strategy-wide optimizations."""
        pass
    self.setup = setup

    def quoted(field=None, raw_field=None, only=None):
        """Determine whether this field should be quoted."""
        return Error("NotImplementedError: quoted must be implemented by a subclass").unwrap()
    self.quoted = quoted

    def _specialchars():
        """The special characters that need to be escaped."""
        return Error("NotImplementedError: _specialchars must be implemented by a subclass").unwrap()

    def specialchars():
        return self._specialchars()
    self.specialchars = larky.property(specialchars)

    def escape_re(quoted=None):
        if quoted:
            return self.escape_re_quoted
        return self.escape_re_unquoted
    self.escape_re = escape_re

    def escapechar(quoted=None):
        if quoted and self.dialect.doublequote:
            return self.dialect.quotechar
        return self.dialect.escapechar
    self.escapechar = escapechar

    def prepare(raw_field, only=None):
        field = text_type(raw_field if raw_field != None else "")
        quoted = self.quoted(field=field, raw_field=raw_field, only=only)

        escape_re = self.escape_re(quoted=quoted)
        escapechar = self.escapechar(quoted=quoted)

        if escape_re.search(field):
            escapechar = "\\\\" if escapechar == "\\" else escapechar
            if not escapechar:
                return Error("Error: No escapechar is set").unwrap()
            escape_replace = r"{escapechar}\1".format(escapechar=escapechar)
            field = escape_re.sub(escape_replace, field)

        if quoted:
            field = "{quotechar}{field}{quotechar}".format(
                quotechar=self.dialect.quotechar, field=field
            )

        return field
    self.prepare = prepare

    def __init__(dialect):
        if self.quoting != None:
            if not (dialect.quoting == self.quoting):
                fail("assert dialect.quoting == self.quoting failed!")
        self.dialect = dialect
        self.setup()

        escape_pattern_quoted = r"({quotechar})".format(
            quotechar=re.escape(self.dialect.quotechar or '"')
        )
        escape_pattern_unquoted = r"([{specialchars}])".format(
            specialchars=re.escape(self.specialchars)
        )

        self.escape_re_quoted = re.compile(escape_pattern_quoted)
        self.escape_re_unquoted = re.compile(escape_pattern_unquoted)
        return self
    self.__init__ = __init__
    return self


def QuoteMinimalStrategy(dialect):
    self =  QuoteStrategy(dialect)
    self.__name__ = 'QuoteMinimalStrategy'
    self.__class__ = QuoteMinimalStrategy
    self.quoting = QUOTE_MINIMAL

    def setup():
        self.quoted_re = re.compile(
            r"[{specialchars}]".format(specialchars=re.escape(self.specialchars))
        )
    self.setup = setup

    def _specialchars():
        return (
            self.dialect.lineterminator
            + self.dialect.quotechar
            + self.dialect.delimiter
            + (self.dialect.escapechar or "")
        )
    self._specialchars = _specialchars

    def quoted(field, only, **kwargs):
        if field == self.dialect.quotechar and not self.dialect.doublequote:
            # If the only character in the field is the quotechar, and
            # doublequote is false, then just escape without outer quotes.
            return False
        return field == "" and only or bool(self.quoted_re.search(field))
    self.quoted = quoted
    return self.__init__(dialect)


def QuoteAllStrategy(dialect):
    self =  QuoteStrategy(dialect)
    self.__name__ = 'QuoteAllStrategy'
    self.__class__ = QuoteAllStrategy
    self.quoting = QUOTE_ALL

    def _specialchars():
        return self.dialect.quotechar
    self._specialchars = _specialchars

    def quoted(**kwargs):
        return True
    self.quoted = quoted
    return self.__init__(dialect)


def QuoteNonnumericStrategy(dialect):
    self =  QuoteStrategy(dialect)
    self.__name__ = 'QuoteNonnumericStrategy'
    self.__class__ = QuoteNonnumericStrategy
    self.quoting = QUOTE_NONNUMERIC

    def _specialchars():
        return (
            self.dialect.lineterminator
            + self.dialect.quotechar
            + self.dialect.delimiter
            + (self.dialect.escapechar or "")
        )
    self._specialchars = _specialchars

    def quoted(raw_field, **kwargs):
        return not (types.is_int(raw_field) or types.is_float(raw_field))
    self.quoted = quoted
    return self.__init__(dialect)


def QuoteNoneStrategy(dialect):
    self =  QuoteStrategy(dialect)
    self.__name__ = 'QuoteNoneStrategy'
    self.__class__ = QuoteNoneStrategy
    self.quoting = QUOTE_NONE

    def _specialchars():
        return (
            self.dialect.lineterminator
            + (self.dialect.quotechar or "")
            + self.dialect.delimiter
            + (self.dialect.escapechar or "")
        )
    self._specialchars = _specialchars

    def quoted(field, only, **kwargs):
        if field == "" and only:
            return Error("Error: single empty field record must be quoted").unwrap()
        return False
    self.quoted = quoted
    return self.__init__(dialect)


def writer(fileobj, dialect="excel", **fmtparams):
    self = larky.mutablestruct(__name__='writer', __class__=writer)
    def __init__(fileobj, dialect, fmtparams):
        if fileobj == None:
            return Error("TypeError: fileobj must be file-like, not None").unwrap()

        self.fileobj = fileobj

        if types.is_string(dialect):
            dialect = get_dialect(dialect)

        self.dialect = _DIALECT.combine(_DIALECT, dialect, fmtparams)

        strategies = {
            QUOTE_MINIMAL: QuoteMinimalStrategy,
            QUOTE_ALL: QuoteAllStrategy,
            QUOTE_NONNUMERIC: QuoteNonnumericStrategy,
            QUOTE_NONE: QuoteNoneStrategy,
        }
        self.strategy = strategies[self.dialect.quoting](self.dialect)
        return self
    self = __init__(fileobj, dialect, fmtparams)

    def writerow(row):
        if row == None:
            return Error("Error: row must be an iterable").unwrap()

        row = list(row)
        only = len(row) == 1
        row = [self.strategy.prepare(field, only=only) for field in row]

        line = self.dialect.delimiter.join(row) + self.dialect.lineterminator
        return self.fileobj.write(line)
    self.writerow = writerow

    def writerows(rows):
        for row in rows:
            self.writerow(row)
    self.writerows = writerows
    return self


START_RECORD = 0
START_FIELD = 1
ESCAPED_CHAR = 2
IN_FIELD = 3
IN_QUOTED_FIELD = 4
ESCAPE_IN_QUOTED_FIELD = 5
QUOTE_IN_QUOTED_FIELD = 6
EAT_CRNL = 7
AFTER_ESCAPED_CRNL = 8


def reader(fileobj, dialect="excel", **fmtparams):
    self = larky.mutablestruct(__name__='reader', __class__=reader)
    def __init__(fileobj, dialect, fmtparams):
        self.input_iter = iter(fileobj)

        if types.is_string(dialect):
            dialect = get_dialect(dialect)
        self.dialect = _DIALECT.combine(_DIALECT, dialect, fmtparams)
        self.fields = None
        self.field = None
        self.line_num = 0
        return self
    self = __init__(fileobj, dialect, fmtparams)

    def parse_reset():
        self.fields = []
        self.field = []
        self.state = START_RECORD
        self.numeric_field = False
    self.parse_reset = parse_reset

    def parse_save_field():
        field = "".join(self.field)
        self.field = []
        if self.numeric_field:
            field = float(field)
            self.numeric_field = False
        self.fields.append(field)
    self.parse_save_field = parse_save_field

    def parse_add_char(c):
        if len(self.field) >= field_size_limit():
            return Error("Error: field size limit exceeded").unwrap()
        self.field.append(c)
    self.parse_add_char = parse_add_char

    def parse_process_char(c):
        switch = {
            START_RECORD: self._parse_start_record,
            START_FIELD: self._parse_start_field,
            ESCAPED_CHAR: self._parse_escaped_char,
            AFTER_ESCAPED_CRNL: self._parse_after_escaped_crnl,
            IN_FIELD: self._parse_in_field,
            IN_QUOTED_FIELD: self._parse_in_quoted_field,
            ESCAPE_IN_QUOTED_FIELD: self._parse_escape_in_quoted_field,
            QUOTE_IN_QUOTED_FIELD: self._parse_quote_in_quoted_field,
            EAT_CRNL: self._parse_eat_crnl,
        }
        return switch[self.state](c)
    self.parse_process_char = parse_process_char

    def _parse_start_record(c):
        if c == "\0":
            return
        elif c == "\n" or c == "\r":
            self.state = EAT_CRNL
            return

        self.state = START_FIELD
        return self._parse_start_field(c)
    self._parse_start_record = _parse_start_record

    def _parse_start_field(c):
        if c == "\n" or c == "\r" or c == "\0":
            self.parse_save_field()
            self.state = START_RECORD if c == "\0" else EAT_CRNL
        elif c == self.dialect.quotechar and self.dialect.quoting != QUOTE_NONE:
            self.state = IN_QUOTED_FIELD
        elif c == self.dialect.escapechar:
            self.state = ESCAPED_CHAR
        elif c == " " and self.dialect.skipinitialspace:
            pass  # Ignore space at start of field
        elif c == self.dialect.delimiter:
            # Save empty field
            self.parse_save_field()
        else:
            # Begin new unquoted field
            if self.dialect.quoting == QUOTE_NONNUMERIC:
                self.numeric_field = True
            self.parse_add_char(c)
            self.state = IN_FIELD
    self._parse_start_field = _parse_start_field

    def _parse_escaped_char(c):
        if c == "\n" or c == "\r":
            self.parse_add_char(c)
            self.state = AFTER_ESCAPED_CRNL
            return
        if c == "\0":
            c = "\n"
        self.parse_add_char(c)
        self.state = IN_FIELD
    self._parse_escaped_char = _parse_escaped_char

    def _parse_after_escaped_crnl(c):
        if c == "\0":
            return
        return self._parse_in_field(c)
    self._parse_after_escaped_crnl = _parse_after_escaped_crnl

    def _parse_in_field(c):
        # In unquoted field
        if c == "\n" or c == "\r" or c == "\0":
            # End of line - return [fields]
            self.parse_save_field()
            self.state = START_RECORD if c == "\0" else EAT_CRNL
        elif c == self.dialect.escapechar:
            self.state = ESCAPED_CHAR
        elif c == self.dialect.delimiter:
            self.parse_save_field()
            self.state = START_FIELD
        else:
            # Normal character - save in field
            self.parse_add_char(c)
    self._parse_in_field = _parse_in_field

    def _parse_in_quoted_field(c):
        if c == "\0":
            pass
        elif c == self.dialect.escapechar:
            self.state = ESCAPE_IN_QUOTED_FIELD
        elif c == self.dialect.quotechar and self.dialect.quoting != QUOTE_NONE:
            if self.dialect.doublequote:
                self.state = QUOTE_IN_QUOTED_FIELD
            else:
                self.state = IN_FIELD
        else:
            self.parse_add_char(c)
    self._parse_in_quoted_field = _parse_in_quoted_field

    def _parse_escape_in_quoted_field(c):
        if c == "\0":
            c = "\n"

        self.parse_add_char(c)
        self.state = IN_QUOTED_FIELD
    self._parse_escape_in_quoted_field = _parse_escape_in_quoted_field

    def _parse_quote_in_quoted_field(c):
        if self.dialect.quoting != QUOTE_NONE and c == self.dialect.quotechar:
            # save "" as "
            self.parse_add_char(c)
            self.state = IN_QUOTED_FIELD
        elif c == self.dialect.delimiter:
            self.parse_save_field()
            self.state = START_FIELD
        elif c == "\n" or c == "\r" or c == "\0":
            # End of line = return [fields]
            self.parse_save_field()
            self.state = START_RECORD if c == "\0" else EAT_CRNL
        elif not self.dialect.strict:
            self.parse_add_char(c)
            self.state = IN_FIELD
        else:
            # illegal
            return Error("{delimiter}' expected after '{quotechar}".format(
                            delimiter=self.dialect.delimiter,
                            quotechar=self.dialect.quotechar,
                        )).unwrap()
    self._parse_quote_in_quoted_field = _parse_quote_in_quoted_field

    def _parse_eat_crnl(c):
        if c == "\n" or c == "\r":
            pass
        elif c == "\0":
            self.state = START_RECORD
        else:
            return Error(
                'new-line character seen in unquoted field - do you ' +
                'need to open the file in universal-newline mode?').unwrap()
    self._parse_eat_crnl = _parse_eat_crnl

    def __iter__():
        return self
    self.__iter__ = __iter__

    def __next__():
        self.parse_reset()
        for _while_ in range(WHILE_LOOP_EMULATION_ITERATION):
            lineobj = safe(next)(self.input_iter)
            if lineobj == StopIteration():
                if len(self.field) != 0 or self.state == IN_QUOTED_FIELD:
                    if self.dialect.strict:
                        return Error("Error: unexpected end of data").unwrap()
                    self.parse_save_field()
                if self.fields:
                    break
                return StopIteration()
            lineobj = lineobj.unwrap()
            if not types.is_string(lineobj):
                err_str = ("iterator should return strings, not {0}" +
                    " (did you open the file in text mode?)")
                return Error(err_str.format(type(lineobj))).unwrap()

            self.line_num += 1
            for c in iter(lineobj):
                if c == "\0":
                    return Error("Error: line contains NULL byte").unwrap()
                self.parse_process_char(c)

            self.parse_process_char("\0")

            if self.state == START_RECORD:
                break

        fields = self.fields
        self.fields = None
        return fields
    self.__next__ = __next__
    self.next = __next__
    return self


_dialect_registry = {}
def register_dialect(name, dialect="excel", **fmtparams):
    if not types.is_string(name):
        return Error("TypeError: 'name' must be a string").unwrap()
    inst = Dialect()
    dialect = inst.extend(inst, dialect, fmtparams)
    inst.validate(inst, dialect)

    if name in _dialect_registry:
        fail("name '%s' already in _dialect_registry!" % name)
    _dialect_registry[name] = dialect


def unregister_dialect(name):
    if name in _dialect_registry:
        _dialect_registry.pop(name)


def get_dialect(name):
    return _dialect_registry[name]


def list_dialects():
    return list(_dialect_registry)


def Dialect():
    """Describe a CSV dialect.

    This must be subclassed (see csv.excel). Valid attributes are:

    delimiter, quotechar, escapechar, doublequote, skipinitialspace,
    lineterminator, quoting, strict.
    """
    self = larky.mutablestruct(__name__='Dialect', __class__=Dialect)
    self._name = ""
    self._valid = False
    # placeholders
    self.delimiter = None
    self.quotechar = None
    self.escapechar = None
    self.doublequote = None
    self.skipinitialspace = None
    self.lineterminator = None
    self.quoting = None
    self.strict = None


    def extend(cls, dialect, fmtparams=None):

        if types.is_string(dialect):
            dialect = get_dialect(dialect)

        if fmtparams == None:
            return dialect

        defaults = cls.defaults()

        if any([param not in defaults for param in fmtparams]):
            return Error("TypeError: Invalid fmtparam").unwrap()

        specified = {}
        for attr in cls.defaults():
            specified[attr] = getattr(dialect, attr, None)

        specified.update(fmtparams)
        # return type(str("ExtendedDialect"), (cls,), specified)
        return larky.mutablestruct(
            __name__='ExtendedDialect',
            __class__=cls.__class__,
            **specified
        )
    self.extend = extend

    def validate(cls, dialect):
        dialect = cls.extend(cls, dialect)

        if not types.is_int(dialect.quoting):
            return Error(("Error: 'quoting' (%s) must be an integer, but is" +
                         " of type: %s") % (
                             repr(dialect.quoting), type(dialect.quoting)
                         )).unwrap()

        if dialect.delimiter == None:
            return Error("Error: delimiter must be set").unwrap()
        cls.validate_text(dialect, "delimiter")

        if dialect.lineterminator == None:
            return Error("Error: lineterminator must be set").unwrap()
        if not types.is_string(dialect.lineterminator):
            return Error("Error: 'lineterminator' must be a string").unwrap()

        if dialect.quoting not in [
            QUOTE_NONE,
            QUOTE_MINIMAL,
            QUOTE_NONNUMERIC,
            QUOTE_ALL,
        ]:
            return Error("Error: Invalid quoting specified").unwrap()

        if dialect.quoting != QUOTE_NONE:
            if dialect.quotechar == None and dialect.escapechar == None:
                return Error("Error: quotechar must be set if quoting enabled").unwrap()
            if dialect.quotechar != None:
                cls.validate_text(dialect, "quotechar")
    self.validate = validate

    def validate_text(dialect, attr):
        val = getattr(dialect, attr)
        if not types.is_string(val):
            if types.is_bytelike(val):
                err = '"{0}" must be string, not bytes'.format(attr)
            else:
                err = '"{0}" must be string, not {1}'.format(attr, type(val))
            return Error(err).unwrap()

        if len(val) != 1:
            return Error('"{0}" must be a 1-character string'.format(attr))

    self.validate_text = validate_text

    def defaults():
        return {
            "delimiter": ",",
            "doublequote": True,
            "escapechar": None,
            "lineterminator": "\r\n",
            "quotechar": '"',
            "quoting": QUOTE_MINIMAL,
            "skipinitialspace": False,
            "strict": False,
        }
    self.defaults = defaults

    def combine(cls, dialect, fmtparams):
        """Create a new dialect with defaults and added parameters."""
        dialect = cls.extend(cls, dialect, fmtparams)
        defaults = cls.defaults()
        specified = dict(
            [(attr, getattr(dialect, attr, None))
            for attr in defaults
            if getattr(dialect, attr, None) != None
            or attr in ["quotechar", "delimiter", "lineterminator", "quoting"]]
        )

        defaults.update(specified)
        # dialect = type(str("CombinedDialect"), (cls,), defaults)
        dialect = larky.mutablestruct(
            __name__='CombinedDialect',
            __class__=cls.__class__,
            **defaults
        )
        cls.validate(cls, dialect)
        return dialect
    self.combine = combine

    def __delattr__(attr):
        if self._valid:
            return Error("AttributeError: dialect is immutable.").unwrap()
        fail("super(Dialect, self).__delattr__(attr)")
    self.__delattr__ = __delattr__

    def __setattr__(attr, value):
        if self._valid:
            return Error("AttributeError: dialect is immutable.").unwrap()
        setattr(self, attr, value)
        # fail("super(Dialect, self).__setattr__(attr, value)")
    self.__setattr__ = __setattr__

    def __init__():
        self.validate(self, self)
        if self.__class__ != Dialect:
            self._valid = True
        return self
    self.__init__ = __init__
    return self


_DIALECT = Dialect()


def excel(init=True):
    """Describe the usual properties of Excel-generated CSV files."""
    self = Dialect()
    self.__name__ = 'excel'
    self.__class__ = excel
    self.delimiter = ","
    self.quotechar = '"'
    self.doublequote = True
    self.skipinitialspace = False
    self.lineterminator = "\r\n"
    self.quoting = QUOTE_MINIMAL
    if init:
        return self.__init__()
    return self

register_dialect("excel", excel())


def excel_tab():
    """Describe the usual properties of Excel-generated TAB-delimited files."""
    self = excel(init=False)
    self.__name__ = 'excel_tab'
    self.__class__ = excel_tab
    self.delimiter = "\t"
    return self.__init__()

register_dialect("excel-tab", excel_tab())


def unix_dialect():
    """Describe the usual properties of Unix-generated CSV files."""
    self = Dialect()
    self.__name__ = 'unix_dialect'
    self.__class__ = unix_dialect
    self.delimiter = ","
    self.quotechar = '"'
    self.doublequote = True
    self.skipinitialspace = False
    self.lineterminator = "\n"
    self.quoting = QUOTE_ALL
    return self.__init__()


register_dialect("unix", unix_dialect())


def DictReader(f,
    fieldnames=None,
    restkey=None,
    restval=None,
    dialect="excel",
    *args,
    **kwds
):
    self = larky.mutablestruct(__name__='DictReader', __class__=DictReader)
    def __init__(
        f,
        fieldnames,
        restkey,
        restval,
        dialect,
        kwds
    ):
        self._fieldnames = fieldnames  # list of keys for the dict
        self.restkey = restkey  # key to catch long rows
        self.restval = restval  # default value for short rows
        self.reader = reader(f, dialect, *args, **kwds)
        self.dialect = dialect
        self.line_num = 0
        return self
    self = __init__(f, fieldnames, restkey, restval, dialect, kwds)

    def __iter__():
        return self
    self.__iter__ = __iter__

    def get_fieldnames():
        if self._fieldnames == None:
            rval = Result.Ok(iter(self.reader)).map(next)
            if rval != StopIteration():
                self._fieldnames = rval.unwrap()
        self.line_num = self.reader.line_num
        return self._fieldnames

    def set_fieldnames(value):
        self._fieldnames = value

    self.fieldnames = larky.property(get_fieldnames, set_fieldnames)

    def __next__():
        if self.line_num == 0:
            # Used only for its side effect.
            self.fieldnames
        row = next(iter(self.reader))
        self.line_num = self.reader.line_num
        for _while_ in range(WHILE_LOOP_EMULATION_ITERATION):
            if row != []:
                break
            row = next(self.reader)
        d = dict(list(zip(self.fieldnames, row)))
        lf = len(self.fieldnames)
        lr = len(row)
        if lf < lr:
            d[self.restkey] = row[lf:]
        elif lf > lr:
            for key in self.fieldnames[lr:]:
                d[key] = self.restval
        return d

    self.__next__ = __next__
    self.next = __next__
    return self


def DictWriter(f,
    fieldnames,
    restval="",
    extrasaction="raise",
    dialect="excel",
    *args,
    **kwds
):
    self = larky.mutablestruct(__name__='DictWriter', __class__=DictWriter)
    def __init__(
        f,
        fieldnames,
        restval,
        extrasaction,
        dialect,
        kwds
    ):
        self.fieldnames = fieldnames  # list of keys for the dict
        self.restval = restval  # for writing short dicts
        if extrasaction.lower() not in ("raise", "ignore",):
            err = (
                "extrasaction (%s) must be 'raise' or 'ignore'" % extrasaction
            )
            return Error("ValueError: " + err).unwrap()
        self.extrasaction = extrasaction
        self.writer = writer(f, dialect, *args, **kwds)
        return self
    self = __init__(f, fieldnames, restval, extrasaction, dialect, kwds)

    def writeheader():
        header = dict(list(zip(self.fieldnames, self.fieldnames)))
        self.writerow(header)
    self.writeheader = writeheader

    def _dict_to_list(rowdict):
        if self.extrasaction == "raise":
            wrong_fields = [k for k in rowdict if k not in self.fieldnames]
            if wrong_fields:
                return Error(
                    "ValueError: " +
                    "dict contains fields not in fieldnames: " +
                    ", ".join([repr(x) for x in wrong_fields])
                ).unwrap()
        return [rowdict.get(key, self.restval) for key in self.fieldnames]
    self._dict_to_list = _dict_to_list

    def writerow(rowdict):
        return self.writer.writerow(self._dict_to_list(rowdict))
    self.writerow = writerow

    def writerows(rowdicts):
        return self.writer.writerows(list(map(self._dict_to_list, rowdicts)))
    self.writerows = writerows
    return self
#

# Guard Sniffer's type checking against builds that exclude complex()
# Larky does not support complex so this is just float
complex = float


# def Sniffer():
#     """
#     "Sniffs" the format of a CSV file (i.e. delimiter, quotechar)
#     Returns a Dialect object.
#     """
#     self = larky.mutablestruct(__name__='Sniffer', __class__=Sniffer)
#
#     def __init__():
#         # in case there is more than one possible delimiter
#         self.preferred = [",", "\t", ";", " ", ":"]
#         return self
#     self = __init__()
#
#     def sniff(self, sample, delimiters=None):
#         """
#         Returns a dialect (or None) corresponding to the sample
#         """
#
#         (
#             quotechar,
#             doublequote,
#             delimiter,
#             skipinitialspace,
#         ) = self._guess_quote_and_delimiter(sample, delimiters)
#         if not delimiter:
#             delimiter, skipinitialspace = self._guess_delimiter(sample, delimiters)
#
#         if not delimiter:
#             return Error("Error: Could not determine delimiter")
#         def dialect():
#             _name = "sniffed"
#             lineterminator = "\r\n"
#             quoting = QUOTE_MINIMAL
#             return self
#             # escapechar = ''
#
#         dialect.doublequote = doublequote
#         dialect.delimiter = delimiter
#         # _csv.reader won't accept a quotechar of ''
#         dialect.quotechar = quotechar or '"'
#         dialect.skipinitialspace = skipinitialspace
#
#         return dialect
#
#     def _guess_quote_and_delimiter(self, data, delimiters):
#         """
#         Looks for text enclosed between two identical quotes
#         (the probable quotechar) which are preceded and followed
#         by the same character (the probable delimiter).
#         For example:
#                          ,'some text',
#         The quote with the most wins, same with the delimiter.
#         If there is no quotechar the delimiter can't be determined
#         this way.
#         """
#
#         matches = []
#         for restr in (
#             "(?P<delim>[^\w\n\"'])(?P<space> ?)(?P<quote>[\"']).*?(?P=quote)(?P=delim)",  # ,".*?",
#             "(?:^|\n)(?P<quote>[\"']).*?(?P=quote)(?P<delim>[^\w\n\"'])(?P<space> ?)",  #  ".*?",
#             "(?P<delim>>[^\w\n\"'])(?P<space> ?)(?P<quote>[\"']).*?(?P=quote)(?:$|\n)",  # ,".*?"
#             "(?:^|\n)(?P<quote>[\"']).*?(?P=quote)(?:$|\n)",
#         ):  #  ".*?" (no delim, no space)
#             regexp = re.compile(restr, re.DOTALL | re.MULTILINE)
#             matches = regexp.findall(data)
#             if matches:
#                 break
#
#         if not matches:
#             # (quotechar, doublequote, delimiter, skipinitialspace)
#             return ("", False, None, 0)
#         quotes = {}
#         delims = {}
#         spaces = 0
#         groupindex = regexp.groupindex
#         for m in matches:
#             n = groupindex["quote"] - 1
#             key = m[n]
#             if key:
#                 quotes[key] = quotes.get(key, 0) + 1
#             try:
#                 n = groupindex["delim"] - 1
#                 key = m[n]
#             except KeyError:
#                 continue
#             if key and (delimiters == None or key in delimiters):
#                 delims[key] = delims.get(key, 0) + 1
#             try:
#                 n = groupindex["space"] - 1
#             except KeyError:
#                 continue
#             if m[n]:
#                 spaces += 1
#
#         quotechar = max(quotes, key=quotes.get)
#
#         if delims:
#             delim = max(delims, key=delims.get)
#             skipinitialspace = delims[delim] == spaces
#             if delim == "\n":  # most likely a file with a single column
#                 delim = ""
#         else:
#             # there is *no* delimiter, it's a single column of quoted data
#             delim = ""
#             skipinitialspace = 0
#
#         # if we see an extra quote between delimiters, we've got a
#         # double quoted format
#         dq_regexp = re.compile(
#             r"((%(delim)s)|^)\W*%(quote)s[^%(delim)s\n]*%(quote)s[^%(delim)s\n]*%(quote)s\W*((%(delim)s)|$)"
#             % {"delim": re.escape(delim), "quote": quotechar},
#             re.MULTILINE,
#         )
#
#         if dq_regexp.search(data):
#             doublequote = True
#         else:
#             doublequote = False
#
#         return (quotechar, doublequote, delim, skipinitialspace)
#
#     def _guess_delimiter(self, data, delimiters):
#         """
#         The delimiter /should/ occur the same number of times on
#         each row. However, due to malformed data, it may not. We don't want
#         an all or nothing approach, so we allow for small variations in this
#         number.
#           1) build a table of the frequency of each character on every line.
#           2) build a table of frequencies of this frequency (meta-frequency?),
#              e.g.  'x occurred 5 times in 10 rows, 6 times in 1000 rows,
#              7 times in 2 rows'
#           3) use the mode of the meta-frequency to determine the /expected/
#              frequency for that character
#           4) find out how often the character actually meets that goal
#           5) the character that best meets its goal is the delimiter
#         For performance reasons, the data is evaluated in chunks, so it can
#         try and evaluate the smallest portion of the data possible, evaluating
#         additional chunks as necessary.
#         """
#
#         data = list([_f for _f in data.split("\n") if _f])
#
#         ascii = [chr(c) for c in range(127)]  # 7-bit ASCII
#
#         # build frequency tables
#         chunkLength = min(10, len(data))
#         iteration = 0
#         charFrequency = {}
#         modes = {}
#         delims = {}
#         start, end = 0, min(chunkLength, len(data))
#         for _while_ in range(WHILE_LOOP_EMULATION_ITERATION):
#             if start >= len(data):
#                 break
#             iteration += 1
#             for line in data[start:end]:
#                 for char in ascii:
#                     metaFrequency = charFrequency.get(char, {})
#                     # must count even if frequency is 0
#                     freq = line.count(char)
#                     # value is the mode
#                     metaFrequency[freq] = metaFrequency.get(freq, 0) + 1
#                     charFrequency[char] = metaFrequency
#
#             for char in list(charFrequency.keys()):
#                 items = list(charFrequency[char].items())
#                 if len(items) == 1 and items[0][0] == 0:
#                     continue
#                 # get the mode of the frequencies
#                 if len(items) > 1:
#                     modes[char] = max(items, key=lambda x: x[1])
#                     # adjust the mode - subtract the sum of all
#                     # other frequencies
#                     items.remove(modes[char])
#                     modes[char] = (
#                         modes[char][0],
#                         modes[char][1] - sum([item[1] for item in items]),
#                     )
#                 else:
#                     modes[char] = items[0]
#
#             # build a list of possible delimiters
#             modeList = list(modes.items())
#             total = float(chunkLength * iteration)
#             # (rows of consistent data) / (number of rows) = 100%
#             consistency = 1.0
#             # minimum consistency threshold
#             threshold = 0.9
#             for _while_ in range(WHILE_LOOP_EMULATION_ITERATION):
#                 if not len(delims) == 0 and consistency >= threshold:
#                     break
#                 for k, v in modeList:
#                     if v[0] > 0 and v[1] > 0:
#                         if (old_div(v[1], total)) >= consistency and (
#                             delimiters == None or k in delimiters
#                         ):
#                             delims[k] = v
#                 consistency -= 0.01
#
#             if len(delims) == 1:
#                 delim = list(delims.keys())[0]
#                 skipinitialspace = data[0].count(delim) == data[0].count("%c " % delim)
#                 return (delim, skipinitialspace)
#
#             # analyze another chunkLength lines
#             start = end
#             end += chunkLength
#
#         if not delims:
#             return ("", 0)
#
#         # if there's more than one, fall back to a 'preferred' list
#         if len(delims) > 1:
#             for d in self.preferred:
#                 if d in list(delims.keys()):
#                     skipinitialspace = data[0].count(d) == data[0].count("%c " % d)
#                     return (d, skipinitialspace)
#
#         # nothing else indicates a preference, pick the character that
#         # dominates(?)
#         items = [(v, k) for (k, v) in list(delims.items())]
#         items.sort()
#         delim = items[-1][1]
#
#         skipinitialspace = data[0].count(delim) == data[0].count("%c " % delim)
#         return (delim, skipinitialspace)
#
#     def has_header(self, sample):
#         # Creates a dictionary of types of data in each column. If any
#         # column is of a single type (say, integers), *except* for the first
#         # row, then the first row is presumed to be labels. If the type
#         # can't be determined, it is assumed to be a string in which case
#         # the length of the string is the determining factor: if all of the
#         # rows except for the first are the same length, it's a header.
#         # Finally, a 'vote' is taken at the end for each column, adding or
#         # subtracting from the likelihood of the first row being a header.
#
#         rdr = reader(StringIO(sample), self.sniff(sample))
#
#         header = next(rdr)  # assume first row is header
#
#         columns = len(header)
#         columnTypes = {}
#         for i in range(columns):
#             columnTypes[i] = None
#
#         checked = 0
#         for row in rdr:
#             # arbitrary number of rows to check, to keep it sane
#             if checked > 20:
#                 break
#             checked += 1
#
#             if len(row) != columns:
#                 continue  # skip rows that have irregular number of columns
#
#             for col in list(columnTypes.keys()):
#
#                 for thisType in [int, float, complex]:
#                     try:
#                         thisType(row[col])
#                         break
#                     except (ValueError, OverflowError):
#                         pass
#                 else:
#                     # fallback to length of string
#                     thisType = len(row[col])
#
#                 if thisType != columnTypes[col]:
#                     if columnTypes[col] == None:  # add new column type
#                         columnTypes[col] = thisType
#                     else:
#                         operator.delitem(columnTypes, col)
#
#         # finally, compare results against first row and "vote"
#         # on whether it's a header
#         hasHeader = 0
#         for col, colType in list(columnTypes.items()):
#             if type(colType) == type(0):  # it's a length
#                 if len(header[col]) != colType:
#                     hasHeader += 1
#                 else:
#                     hasHeader -= 1
#             else:  # attempt typecast
#                 try:
#                     colType(header[col])
#                 except (ValueError, TypeError):
#                     hasHeader += 1
#                 else:
#                     hasHeader -= 1
#
#         return hasHeader > 0
#     return self
#


csv = larky.struct(
    __name__='csv',
    _dialects=_dialects,
    field_size_limit=field_size_limit,
    QuoteStrategy=QuoteStrategy,
    QuoteMinimalStrategy=QuoteMinimalStrategy,
    QuoteAllStrategy=QuoteAllStrategy,
    QuoteNonnumericStrategy=QuoteNonnumericStrategy,
    QuoteNoneStrategy=QuoteNoneStrategy,
    reader=reader,
    writer=writer,
    register_dialect=register_dialect,
    unregister_dialect=unregister_dialect,
    get_dialect=get_dialect,
    list_dialects=list_dialects,
    Dialect=Dialect,
    excel=excel,
    excel_tab=excel_tab,
    unix_dialect=unix_dialect,
    DictReader=DictReader,
    DictWriter=DictWriter,
)