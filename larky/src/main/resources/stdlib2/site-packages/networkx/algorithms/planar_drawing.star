def combinatorial_embedding_to_pos(embedding, fully_triangulate=False):
    """
    Assigns every node a (x, y) position based on the given embedding

        The algorithm iteratively inserts nodes of the input graph in a certain
        order and rearranges previously inserted nodes so that the planar drawing
        stays valid. This is done efficiently by only maintaining relative
        positions during the node placements and calculating the absolute positions
        at the end. For more information see [1]_.

        Parameters
        ----------
        embedding : nx.PlanarEmbedding
            This defines the order of the edges

        fully_triangulate : bool
            If set to True the algorithm adds edges to a copy of the input
            embedding and makes it chordal.

        Returns
        -------
        pos : dict
            Maps each node to a tuple that defines the (x, y) position

        References
        ----------
        .. [1] M. Chrobak and T.H. Payne:
            A Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989
            http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677

    
    """
def set_position(parent, tree, remaining_nodes, delta_x, y_coordinate, pos):
    """
    Helper method to calculate the absolute position of nodes.
    """
def get_canonical_ordering(embedding, outer_face):
    """
    Returns a canonical ordering of the nodes

        The canonical ordering of nodes (v1, ..., vn) must fulfill the following
        conditions:
        (See Lemma 1 in [2]_)

        - For the subgraph G_k of the input graph induced by v1, ..., vk it holds:
            - 2-connected
            - internally triangulated
            - the edge (v1, v2) is part of the outer face
        - For a node v(k+1) the following holds:
            - The node v(k+1) is part of the outer face of G_k
            - It has at least two neighbors in G_k
            - All neighbors of v(k+1) in G_k lie consecutively on the outer face of
              G_k (excluding the edge (v1, v2)).

        The algorithm used here starts with G_n (containing all nodes). It first
        selects the nodes v1 and v2. And then tries to find the order of the other
        nodes by checking which node can be removed in order to fulfill the
        conditions mentioned above. This is done by calculating the number of
        chords of nodes on the outer face. For more information see [1]_.

        Parameters
        ----------
        embedding : nx.PlanarEmbedding
            The embedding must be triangulated
        outer_face : list
            The nodes on the outer face of the graph

        Returns
        -------
        ordering : list
            A list of tuples `(vk, wp_wq)`. Here `vk` is the node at this position
            in the canonical ordering. The element `wp_wq` is a list of nodes that
            make up the outer face of G_k.

        References
        ----------
        .. [1] Steven Chaplick.
            Canonical Orders of Planar Graphs and (some of) Their Applications 2015
            https://wuecampus2.uni-wuerzburg.de/moodle/pluginfile.php/545727/mod_resource/content/0/vg-ss15-vl03-canonical-orders-druckversion.pdf
        .. [2] M. Chrobak and T.H. Payne:
            A Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989
            http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677

    
    """
    def is_outer_face_nbr(x, y):
        """
         Initialize number of chords

        """
def triangulate_face(embedding, v1, v2):
    """
    Triangulates the face given by half edge (v, w)

        Parameters
        ----------
        embedding : nx.PlanarEmbedding
        v1 : node
            The half-edge (v1, v2) belongs to the face that gets triangulated
        v2 : node
    
    """
def triangulate_embedding(embedding, fully_triangulate=True):
    """
    Triangulates the embedding.

        Traverses faces of the embedding and adds edges to a copy of the
        embedding to triangulate it.
        The method also ensures that the resulting graph is 2-connected by adding
        edges if the same vertex is contained twice on a path around a face.

        Parameters
        ----------
        embedding : nx.PlanarEmbedding
            The input graph must contain at least 3 nodes.

        fully_triangulate : bool
            If set to False the face with the most nodes is chooses as outer face.
            This outer face does not get triangulated.

        Returns
        -------
        (embedding, outer_face) : (nx.PlanarEmbedding, list) tuple
            The element `embedding` is a new embedding containing all edges from
            the input embedding and the additional edges to triangulate the graph.
            The element `outer_face` is a list of nodes that lie on the outer face.
            If the graph is fully triangulated these are three arbitrary connected
            nodes.

    
    """
def make_bi_connected(embedding, starting_node, outgoing_node, edges_counted):
    """
    Triangulate a face and make it 2-connected

        This method also adds all edges on the face to `edges_counted`.

        Parameters
        ----------
        embedding: nx.PlanarEmbedding
            The embedding that defines the faces
        starting_node : node
            A node on the face
        outgoing_node : node
            A node such that the half edge (starting_node, outgoing_node) belongs
            to the face
        edges_counted: set
            Set of all half-edges that belong to a face that have been visited

        Returns
        -------
        face_nodes: list
            A list of all nodes at the border of this face
    
    """
