2021-03-02 20:47:13,623 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,623 : INFO : tokenize_signature : --> do i ever get here?
def boruvka_mst_edges(
    G, minimum=True, weight="weight", keys=False, data=True, ignore_nan=False
):
    """
    Iterate over edges of a Borůvka's algorithm min/max spanning tree.

        Parameters
        ----------
        G : NetworkX Graph
            The edges of `G` must have distinct weights,
            otherwise the edges may not form a tree.

        minimum : bool (default: True)
            Find the minimum (True) or maximum (False) spanning tree.

        weight : string (default: 'weight')
            The name of the edge attribute holding the edge weights.

        keys : bool (default: True)
            This argument is ignored since this function is not
            implemented for multigraphs; it exists only for consistency
            with the other minimum spanning tree functions.

        data : bool (default: True)
            Flag for whether to yield edge attribute dicts.
            If True, yield edges `(u, v, d)`, where `d` is the attribute dict.
            If False, yield edges `(u, v)`.

        ignore_nan : bool (default: False)
            If a NaN is found as an edge weight normally an exception is raised.
            If `ignore_nan is True` then that edge is ignored instead.

    
    """
    def best_edge(component):
        """
        Returns the optimum (minimum or maximum) edge on the edge
                boundary of the given set of nodes.

                A return value of ``None`` indicates an empty boundary.

        
        """
2021-03-02 20:47:13,625 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,625 : INFO : tokenize_signature : --> do i ever get here?
def kruskal_mst_edges(
    G, minimum, weight="weight", keys=True, data=True, ignore_nan=False
):
    """
    Iterate over edges of a Kruskal's algorithm min/max spanning tree.

        Parameters
        ----------
        G : NetworkX Graph
            The graph holding the tree of interest.

        minimum : bool (default: True)
            Find the minimum (True) or maximum (False) spanning tree.

        weight : string (default: 'weight')
            The name of the edge attribute holding the edge weights.

        keys : bool (default: True)
            If `G` is a multigraph, `keys` controls whether edge keys ar yielded.
            Otherwise `keys` is ignored.

        data : bool (default: True)
            Flag for whether to yield edge attribute dicts.
            If True, yield edges `(u, v, d)`, where `d` is the attribute dict.
            If False, yield edges `(u, v)`.

        ignore_nan : bool (default: False)
            If a NaN is found as an edge weight normally an exception is raised.
            If `ignore_nan is True` then that edge is ignored instead.

    
    """
        def filter_nan_edges(edges=edges, weight=weight):
            """
            f"NaN found as an edge weight. Edge {(u, v, k, d)}
            """
        def filter_nan_edges(edges=edges, weight=weight):
            """
            f"NaN found as an edge weight. Edge {(u, v, d)}
            """
def prim_mst_edges(G, minimum, weight="weight", keys=True, data=True, ignore_nan=False):
    """
    Iterate over edges of Prim's algorithm min/max spanning tree.

        Parameters
        ----------
        G : NetworkX Graph
            The graph holding the tree of interest.

        minimum : bool (default: True)
            Find the minimum (True) or maximum (False) spanning tree.

        weight : string (default: 'weight')
            The name of the edge attribute holding the edge weights.

        keys : bool (default: True)
            If `G` is a multigraph, `keys` controls whether edge keys ar yielded.
            Otherwise `keys` is ignored.

        data : bool (default: True)
            Flag for whether to yield edge attribute dicts.
            If True, yield edges `(u, v, d)`, where `d` is the attribute dict.
            If False, yield edges `(u, v)`.

        ignore_nan : bool (default: False)
            If a NaN is found as an edge weight normally an exception is raised.
            If `ignore_nan is True` then that edge is ignored instead.

    
    """
2021-03-02 20:47:13,629 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,629 : INFO : tokenize_signature : --> do i ever get here?
def minimum_spanning_edges(
    G, algorithm="kruskal", weight="weight", keys=True, data=True, ignore_nan=False
):
    """
    Generate edges in a minimum spanning forest of an undirected
        weighted graph.

        A minimum spanning tree is a subgraph of the graph (a tree)
        with the minimum sum of edge weights.  A spanning forest is a
        union of the spanning trees for each connected component of the graph.

        Parameters
        ----------
        G : undirected Graph
           An undirected graph. If `G` is connected, then the algorithm finds a
           spanning tree. Otherwise, a spanning forest is found.

        algorithm : string
           The algorithm to use when finding a minimum spanning tree. Valid
           choices are 'kruskal', 'prim', or 'boruvka'. The default is 'kruskal'.

        weight : string
           Edge data key to use for weight (default 'weight').

        keys : bool
           Whether to yield edge key in multigraphs in addition to the edge.
           If `G` is not a multigraph, this is ignored.

        data : bool, optional
           If True yield the edge data along with the edge.

        ignore_nan : bool (default: False)
            If a NaN is found as an edge weight normally an exception is raised.
            If `ignore_nan is True` then that edge is ignored instead.

        Returns
        -------
        edges : iterator
           An iterator over edges in a maximum spanning tree of `G`.
           Edges connecting nodes `u` and `v` are represented as tuples:
           `(u, v, k, d)` or `(u, v, k)` or `(u, v, d)` or `(u, v)`

           If `G` is a multigraph, `keys` indicates whether the edge key `k` will
           be reported in the third position in the edge tuple. `data` indicates
           whether the edge datadict `d` will appear at the end of the edge tuple.

           If `G` is not a multigraph, the tuples are `(u, v, d)` if `data` is True
           or `(u, v)` if `data` is False.

        Examples
        --------
        >>> from networkx.algorithms import tree

        Find minimum spanning edges by Kruskal's algorithm

        >>> G = nx.cycle_graph(4)
        >>> G.add_edge(0, 3, weight=2)
        >>> mst = tree.minimum_spanning_edges(G, algorithm="kruskal", data=False)
        >>> edgelist = list(mst)
        >>> sorted(sorted(e) for e in edgelist)
        [[0, 1], [1, 2], [2, 3]]

        Find minimum spanning edges by Prim's algorithm

        >>> G = nx.cycle_graph(4)
        >>> G.add_edge(0, 3, weight=2)
        >>> mst = tree.minimum_spanning_edges(G, algorithm="prim", data=False)
        >>> edgelist = list(mst)
        >>> sorted(sorted(e) for e in edgelist)
        [[0, 1], [1, 2], [2, 3]]

        Notes
        -----
        For Borůvka's algorithm, each edge must have a weight attribute, and
        each edge weight must be distinct.

        For the other algorithms, if the graph edges do not have a weight
        attribute a default weight of 1 will be used.

        Modified code from David Eppstein, April 2006
        http://www.ics.uci.edu/~eppstein/PADS/

    
    """
2021-03-02 20:47:13,630 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,630 : INFO : tokenize_signature : --> do i ever get here?
def maximum_spanning_edges(
    G, algorithm="kruskal", weight="weight", keys=True, data=True, ignore_nan=False
):
    """
    Generate edges in a maximum spanning forest of an undirected
        weighted graph.

        A maximum spanning tree is a subgraph of the graph (a tree)
        with the maximum possible sum of edge weights.  A spanning forest is a
        union of the spanning trees for each connected component of the graph.

        Parameters
        ----------
        G : undirected Graph
           An undirected graph. If `G` is connected, then the algorithm finds a
           spanning tree. Otherwise, a spanning forest is found.

        algorithm : string
           The algorithm to use when finding a maximum spanning tree. Valid
           choices are 'kruskal', 'prim', or 'boruvka'. The default is 'kruskal'.

        weight : string
           Edge data key to use for weight (default 'weight').

        keys : bool
           Whether to yield edge key in multigraphs in addition to the edge.
           If `G` is not a multigraph, this is ignored.

        data : bool, optional
           If True yield the edge data along with the edge.

        ignore_nan : bool (default: False)
            If a NaN is found as an edge weight normally an exception is raised.
            If `ignore_nan is True` then that edge is ignored instead.

        Returns
        -------
        edges : iterator
           An iterator over edges in a maximum spanning tree of `G`.
           Edges connecting nodes `u` and `v` are represented as tuples:
           `(u, v, k, d)` or `(u, v, k)` or `(u, v, d)` or `(u, v)`

           If `G` is a multigraph, `keys` indicates whether the edge key `k` will
           be reported in the third position in the edge tuple. `data` indicates
           whether the edge datadict `d` will appear at the end of the edge tuple.

           If `G` is not a multigraph, the tuples are `(u, v, d)` if `data` is True
           or `(u, v)` if `data` is False.

        Examples
        --------
        >>> from networkx.algorithms import tree

        Find maximum spanning edges by Kruskal's algorithm

        >>> G = nx.cycle_graph(4)
        >>> G.add_edge(0, 3, weight=2)
        >>> mst = tree.maximum_spanning_edges(G, algorithm="kruskal", data=False)
        >>> edgelist = list(mst)
        >>> sorted(sorted(e) for e in edgelist)
        [[0, 1], [0, 3], [1, 2]]

        Find maximum spanning edges by Prim's algorithm

        >>> G = nx.cycle_graph(4)
        >>> G.add_edge(0, 3, weight=2)  # assign weight 2 to edge 0-3
        >>> mst = tree.maximum_spanning_edges(G, algorithm="prim", data=False)
        >>> edgelist = list(mst)
        >>> sorted(sorted(e) for e in edgelist)
        [[0, 1], [0, 3], [2, 3]]

        Notes
        -----
        For Borůvka's algorithm, each edge must have a weight attribute, and
        each edge weight must be distinct.

        For the other algorithms, if the graph edges do not have a weight
        attribute a default weight of 1 will be used.

        Modified code from David Eppstein, April 2006
        http://www.ics.uci.edu/~eppstein/PADS/
    
    """
def minimum_spanning_tree(G, weight="weight", algorithm="kruskal", ignore_nan=False):
    """
    Returns a minimum spanning tree or forest on an undirected graph `G`.

        Parameters
        ----------
        G : undirected graph
            An undirected graph. If `G` is connected, then the algorithm finds a
            spanning tree. Otherwise, a spanning forest is found.

        weight : str
           Data key to use for edge weights.

        algorithm : string
           The algorithm to use when finding a minimum spanning tree. Valid
           choices are 'kruskal', 'prim', or 'boruvka'. The default is
           'kruskal'.

        ignore_nan : bool (default: False)
            If a NaN is found as an edge weight normally an exception is raised.
            If `ignore_nan is True` then that edge is ignored instead.

        Returns
        -------
        G : NetworkX Graph
           A minimum spanning tree or forest.

        Examples
        --------
        >>> G = nx.cycle_graph(4)
        >>> G.add_edge(0, 3, weight=2)
        >>> T = nx.minimum_spanning_tree(G)
        >>> sorted(T.edges(data=True))
        [(0, 1, {}), (1, 2, {}), (2, 3, {})]


        Notes
        -----
        For Borůvka's algorithm, each edge must have a weight attribute, and
        each edge weight must be distinct.

        For the other algorithms, if the graph edges do not have a weight
        attribute a default weight of 1 will be used.

        There may be more than one tree with the same minimum or maximum weight.
        See :mod:`networkx.tree.recognition` for more detailed definitions.

        Isolated nodes with self-loops are in the tree as edgeless isolated nodes.

    
    """
def maximum_spanning_tree(G, weight="weight", algorithm="kruskal", ignore_nan=False):
    """
    Returns a maximum spanning tree or forest on an undirected graph `G`.

        Parameters
        ----------
        G : undirected graph
            An undirected graph. If `G` is connected, then the algorithm finds a
            spanning tree. Otherwise, a spanning forest is found.

        weight : str
           Data key to use for edge weights.

        algorithm : string
           The algorithm to use when finding a maximum spanning tree. Valid
           choices are 'kruskal', 'prim', or 'boruvka'. The default is
           'kruskal'.

        ignore_nan : bool (default: False)
            If a NaN is found as an edge weight normally an exception is raised.
            If `ignore_nan is True` then that edge is ignored instead.


        Returns
        -------
        G : NetworkX Graph
           A maximum spanning tree or forest.


        Examples
        --------
        >>> G = nx.cycle_graph(4)
        >>> G.add_edge(0, 3, weight=2)
        >>> T = nx.maximum_spanning_tree(G)
        >>> sorted(T.edges(data=True))
        [(0, 1, {}), (0, 3, {'weight': 2}), (1, 2, {})]


        Notes
        -----
        For Borůvka's algorithm, each edge must have a weight attribute, and
        each edge weight must be distinct.

        For the other algorithms, if the graph edges do not have a weight
        attribute a default weight of 1 will be used.

        There may be more than one tree with the same minimum or maximum weight.
        See :mod:`networkx.tree.recognition` for more detailed definitions.

        Isolated nodes with self-loops are in the tree as edgeless isolated nodes.

    
    """
