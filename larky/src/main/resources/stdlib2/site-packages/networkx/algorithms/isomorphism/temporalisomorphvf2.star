def TimeRespectingGraphMatcher(GraphMatcher):
    """
    Initialize TimeRespectingGraphMatcher.

            G1 and G2 should be nx.Graph or nx.MultiGraph instances.

            Examples
            --------
            To create a TimeRespectingGraphMatcher which checks for
            syntactic and semantic feasibility:

            >>> from networkx.algorithms import isomorphism
            >>> from datetime import timedelta
            >>> G1 = nx.Graph(nx.path_graph(4, create_using=nx.Graph()))

            >>> G2 = nx.Graph(nx.path_graph(4, create_using=nx.Graph()))

            >>> GM = isomorphism.TimeRespectingGraphMatcher(
            ...     G1, G2, "date", timedelta(days=1)
            ... )
        
    """
    def one_hop(self, Gx, Gx_node, neighbors):
        """

                Edges one hop out from a node in the mapping should be
                time-respecting with respect to each other.
        
        """
    def two_hop(self, Gx, core_x, Gx_node, neighbors):
        """

                Paths of length 2 from Gx_node should be time-respecting.
        
        """
    def semantic_feasibility(self, G1_node, G2_node):
        """
        Returns True if adding (G1_node, G2_node) is semantically
                feasible.

                Any subclass which redefines semantic_feasibility() must
                maintain the self.tests if needed, to keep the match() method
                functional. Implementations should consider multigraphs.
        
        """
def TimeRespectingDiGraphMatcher(DiGraphMatcher):
    """
    Initialize TimeRespectingDiGraphMatcher.

            G1 and G2 should be nx.DiGraph or nx.MultiDiGraph instances.

            Examples
            --------
            To create a TimeRespectingDiGraphMatcher which checks for
            syntactic and semantic feasibility:

            >>> from networkx.algorithms import isomorphism
            >>> from datetime import timedelta
            >>> G1 = nx.DiGraph(nx.path_graph(4, create_using=nx.DiGraph()))

            >>> G2 = nx.DiGraph(nx.path_graph(4, create_using=nx.DiGraph()))

            >>> GM = isomorphism.TimeRespectingDiGraphMatcher(
            ...     G1, G2, "date", timedelta(days=1)
            ... )
        
    """
    def get_pred_dates(self, Gx, Gx_node, core_x, pred):
        """

                Get the dates of edges from predecessors.
        
        """
    def get_succ_dates(self, Gx, Gx_node, core_x, succ):
        """

                Get the dates of edges to successors.
        
        """
    def one_hop(self, Gx, Gx_node, core_x, pred, succ):
        """

                The ego node.
        
        """
    def two_hop_pred(self, Gx, Gx_node, core_x, pred):
        """

                The predeccessors of the ego node.
        
        """
    def two_hop_succ(self, Gx, Gx_node, core_x, succ):
        """

                The successors of the ego node.
        
        """
    def preds(self, Gx, core_x, v, Gx_node=None):
        """

                Edges one hop out from Gx_node in the mapping should be
                time-respecting with respect to each other, regardless of
                direction.
        
        """
    def test_two(self, pred_dates, succ_dates):
        """

                Edges from a dual Gx_node in the mapping should be ordered in
                a time-respecting manner.
        
        """
    def semantic_feasibility(self, G1_node, G2_node):
        """
        Returns True if adding (G1_node, G2_node) is semantically
                feasible.

                Any subclass which redefines semantic_feasibility() must
                maintain the self.tests if needed, to keep the match() method
                functional. Implementations should consider multigraphs.
        
        """
