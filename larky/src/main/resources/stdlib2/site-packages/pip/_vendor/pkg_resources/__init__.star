def PEP440Warning(RuntimeWarning):
    """

        Used when there is an issue with a version or specifier not complying with
        PEP 440.
    
    """
def parse_version(v):
    """
    '_sget_'
    """
def __setstate__(state):
    """
    '_sset_'
    """
def _sget_dict(val):
    """
    Return this platform's maximum compatible version.

        distutils.util.get_platform() normally reports the minimum version
        of Mac OS X that would be required to *use* extensions produced by
        distutils.  But what we want when checking compatibility is to know the
        version of Mac OS X that we are *running*.  To allow usage of packages that
        explicitly require a newer version of Mac OS X, we must also know the
        current version of the OS.

        If this condition occurs for any other platform with a version in its
        platform strings, this function should be extended accordingly.
    
    """
def ResolutionError(Exception):
    """
    Abstract base for dependency resolution errors
    """
    def __repr__(self):
        """

            An already-installed version conflicts with the requested version.

            Should be initialized with the installed Distribution and the requested
            Requirement.
    
        """
    def dist(self):
        """

                If required_by is non-empty, return a version of self that is a
                ContextualVersionConflict.
        
        """
def ContextualVersionConflict(VersionConflict):
    """

        A VersionConflict that accepts a third parameter, the set of the
        requirements that required the installed Distribution.
    
    """
    def required_by(self):
        """
        A requested distribution was not found
        """
    def req(self):
        """
        'the application'
        """
    def report(self):
        """
        Distribution doesn't have an "extra feature" of the given name
        """
def register_loader_type(loader_type, provider_factory):
    """
    Register `provider_factory` to make providers for `loader_type`

        `loader_type` is the type or class of a PEP 302 ``module.__loader__``,
        and `provider_factory` is a function that, passed a *module* object,
        returns an ``IResourceProvider`` for that module.
    
    """
def get_provider(moduleOrReq):
    """
    Return an IResourceProvider for the named module or requirement
    """
def _macosx_vers(_cache=[]):
    """
     fallback for MacPorts

    """
def _macosx_arch(machine):
    """
    'PowerPC'
    """
def get_build_platform():
    """
    Return this platform's string for platform-specific distributions

        XXX Currently this is the same as ``distutils.util.get_platform()``, but it
        needs some hacks for Linux and Mac OS X.
    
    """
def compatible_platforms(provided, required):
    """
    Can code for the `provided` platform run on the `required` platform?

        Returns true if either platform is ``None``, or the platforms are equal.

        XXX Needs compatibility checks for Linux and other unixy OSes.
    
    """
def run_script(dist_spec, script_name):
    """
    Locate distribution `dist_spec` and run its `script_name` script
    """
def get_distribution(dist):
    """
    Return a current distribution object for a Requirement or string
    """
def load_entry_point(dist, group, name):
    """
    Return `name` entry point of `group` for `dist` or raise ImportError
    """
def get_entry_map(dist, group=None):
    """
    Return the entry point map for `group`, or the full entry map
    """
def get_entry_info(dist, group, name):
    """
    Return the EntryPoint object for `group`+`name`, or ``None``
    """
def IMetadataProvider:
    """
    Does the package's distribution contain the named metadata?
    """
    def get_metadata(name):
        """
        The named metadata resource as a string
        """
    def get_metadata_lines(name):
        """
        Yield named metadata resource as list of non-blank non-comment lines

               Leading and trailing whitespace is stripped from each line, and lines
               with ``#`` as the first non-blank character are omitted.
        """
    def metadata_isdir(name):
        """
        Is the named metadata a directory?  (like ``os.path.isdir()``)
        """
    def metadata_listdir(name):
        """
        List of metadata names in the directory (like ``os.listdir()``)
        """
    def run_script(script_name, namespace):
        """
        Execute the named script in the supplied namespace dictionary
        """
def IResourceProvider(IMetadataProvider):
    """
    An object that provides access to package resources
    """
    def get_resource_filename(manager, resource_name):
        """
        Return a true filesystem path for `resource_name`

                `manager` must be an ``IResourceManager``
        """
    def get_resource_stream(manager, resource_name):
        """
        Return a readable file-like object for `resource_name`

                `manager` must be an ``IResourceManager``
        """
    def get_resource_string(manager, resource_name):
        """
        Return a string containing the contents of `resource_name`

                `manager` must be an ``IResourceManager``
        """
    def has_resource(resource_name):
        """
        Does the package contain the named resource?
        """
    def resource_isdir(resource_name):
        """
        Is the named resource a directory?  (like ``os.path.isdir()``)
        """
    def resource_listdir(resource_name):
        """
        List of resource names in the directory (like ``os.listdir()``)
        """
def WorkingSet:
    """
    A collection of active distributions on sys.path (or a similar list)
    """
    def __init__(self, entries=None):
        """
        Create working set from list of path entries (default=sys.path)
        """
    def _build_master(cls):
        """

                Prepare the master working set.
        
        """
    def _build_from_requirements(cls, req_spec):
        """

                Build a working set from a requirement spec. Rewrites sys.path.
        
        """
    def add_entry(self, entry):
        """
        Add a path item to ``.entries``, finding any distributions on it

                ``find_distributions(entry, True)`` is used to find distributions
                corresponding to the path entry, and they are added.  `entry` is
                always appended to ``.entries``, even if it is already present.
                (This is because ``sys.path`` can contain the same value more than
                once, and the ``.entries`` of the ``sys.path`` WorkingSet should always
                equal ``sys.path``.)
        
        """
    def __contains__(self, dist):
        """
        True if `dist` is the active distribution for its project
        """
    def find(self, req):
        """
        Find a distribution matching requirement `req`

                If there is an active distribution for the requested project, this
                returns it as long as it meets the version requirement specified by
                `req`.  But, if there is an active distribution for the project and it
                does *not* meet the `req` requirement, ``VersionConflict`` is raised.
                If there is no active distribution for the requested project, ``None``
                is returned.
        
        """
    def iter_entry_points(self, group, name=None):
        """
        Yield entry point objects from `group` matching `name`

                If `name` is None, yields all entry points in `group` from all
                distributions in the working set, otherwise only ones matching
                both `group` and `name` are yielded (in distribution order).
        
        """
    def run_script(self, requires, script_name):
        """
        Locate distribution for `requires` and run `script_name` script
        """
    def __iter__(self):
        """
        Yield distributions for non-duplicate projects in the working set

                The yield order is the order in which the items' path entries were
                added to the working set.
        
        """
    def add(self, dist, entry=None, insert=True, replace=False):
        """
        Add `dist` to working set, associated with `entry`

                If `entry` is unspecified, it defaults to the ``.location`` of `dist`.
                On exit from this routine, `entry` is added to the end of the working
                set's ``.entries`` (if it wasn't already present).

                `dist` is only added to the working set if it's for a project that
                doesn't already have a distribution in the set, unless `replace=True`.
                If it's added, any callbacks registered with the ``subscribe()`` method
                will be called.
        
        """
2021-03-02 20:51:28,440 : INFO : tokenize_signature : --> do i ever get here?
    def resolve(self, requirements, env=None, installer=None,
                replace_conflicting=False, extras=None):
        """
        List all distributions needed to (recursively) meet `requirements`

                `requirements` must be a sequence of ``Requirement`` objects.  `env`,
                if supplied, should be an ``Environment`` instance.  If
                not supplied, it defaults to all distributions available within any
                entry or distribution in the working set.  `installer`, if supplied,
                will be invoked with each requirement that cannot be met by an
                already-installed distribution; it should return a ``Distribution`` or
                ``None``.

                Unless `replace_conflicting=True`, raises a VersionConflict exception
                if
                any requirements are found on the path that have the correct name but
                the wrong version.  Otherwise, if an `installer` is supplied it will be
                invoked to obtain the correct version of the requirement and activate
                it.

                `extras` is a list of the extras to be used with these requirements.
                This is important because extra requirements may look like `my_req;
                extra = "my_extra"`, which would otherwise be interpreted as a purely
                optional requirement.  Instead, we want to be able to assert that these
                requirements are truly required.
        
        """
2021-03-02 20:51:28,442 : INFO : tokenize_signature : --> do i ever get here?
    def find_plugins(
            self, plugin_env, full_env=None, installer=None, fallback=True):
        """
        Find all activatable distributions in `plugin_env`

                Example usage::

                    distributions, errors = working_set.find_plugins(
                        Environment(plugin_dirlist)
                    )
                    # add plugins+libs to sys.path
                    map(working_set.add, distributions)
                    # display errors
                    print('Could not load', errors)

                The `plugin_env` should be an ``Environment`` instance that contains
                only distributions that are in the project's "plugin directory" or
                directories. The `full_env`, if supplied, should be an ``Environment``
                contains all currently-available distributions.  If `full_env` is not
                supplied, one is created automatically from the ``WorkingSet`` this
                method is called on, which will typically mean that every directory on
                ``sys.path`` will be scanned for distributions.

                `installer` is a standard installer callback as used by the
                ``resolve()`` method. The `fallback` flag indicates whether we should
                attempt to resolve older versions of a plugin if the newest version
                cannot be resolved.

                This method returns a 2-tuple: (`distributions`, `error_info`), where
                `distributions` is a list of the distributions found in `plugin_env`
                that were loadable, along with any other distributions that are needed
                to resolve their dependencies.  `error_info` is a dictionary mapping
                unloadable plugin distributions to an exception instance describing the
                error that occurred. Usually this will be a ``DistributionNotFound`` or
                ``VersionConflict`` instance.
        
        """
    def require(self, *requirements):
        """
        Ensure that distributions matching `requirements` are activated

                `requirements` must be a string or a (possibly-nested) sequence
                thereof, specifying the distributions and versions required.  The
                return value is a sequence of the distributions that needed to be
                activated to fulfill the requirements; all relevant distributions are
                included, even if they were already activated in this working set.
        
        """
    def subscribe(self, callback, existing=True):
        """
        Invoke `callback` for all distributions

                If `existing=True` (default),
                call on all existing ones, as well.
        
        """
    def _added_new(self, dist):
        """

            Map each requirement to the extras that demanded it.
    
        """
    def markers_pass(self, req, extras=None):
        """

                Evaluate markers for req against each extra that
                demanded it.

                Return False if the req has a marker and fails
                evaluation. Otherwise, return True.
        
        """
def Environment:
    """
    Searchable snapshot of distributions on a search path
    """
2021-03-02 20:51:28,444 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:28,444 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
            self, search_path=None, platform=get_supported_platform(),
            python=PY_MAJOR):
        """
        Snapshot distributions available on a search path

                Any distributions found on `search_path` are added to the environment.
                `search_path` should be a sequence of ``sys.path`` items.  If not
                supplied, ``sys.path`` is used.

                `platform` is an optional string specifying the name of the platform
                that platform-specific distributions must be compatible with.  If
                unspecified, it defaults to the current platform.  `python` is an
                optional string naming the desired version of Python (e.g. ``'3.6'``);
                it defaults to the current version.

                You may explicitly set `platform` (and/or `python`) to ``None`` if you
                wish to map *all* distributions, not just those compatible with the
                running platform or Python version.
        
        """
    def can_add(self, dist):
        """
        Is distribution `dist` acceptable for this environment?

                The distribution must match the platform and python version
                requirements specified when this environment was created, or False
                is returned.
        
        """
    def remove(self, dist):
        """
        Remove `dist` from the environment
        """
    def scan(self, search_path=None):
        """
        Scan `search_path` for distributions usable in this environment

                Any distributions found are added to the environment.
                `search_path` should be a sequence of ``sys.path`` items.  If not
                supplied, ``sys.path`` is used.  Only distributions conforming to
                the platform/python version defined at initialization are added.
        
        """
    def __getitem__(self, project_name):
        """
        Return a newest-to-oldest list of distributions for `project_name`

                Uses case-insensitive `project_name` comparison, assuming all the
                project's distributions use their project's name converted to all
                lowercase as their key.

        
        """
    def add(self, dist):
        """
        Add `dist` if we ``can_add()`` it and it has not already been added
        
        """
2021-03-02 20:51:28,446 : INFO : tokenize_signature : --> do i ever get here?
    def best_match(
            self, req, working_set, installer=None, replace_conflicting=False):
        """
        Find distribution best matching `req` and usable on `working_set`

                This calls the ``find(req)`` method of the `working_set` to see if a
                suitable distribution is already active.  (This may raise
                ``VersionConflict`` if an unsuitable version of the project is already
                active in the specified `working_set`.)  If a suitable distribution
                isn't active, this method returns the newest distribution in the
                environment that meets the ``Requirement`` in `req`.  If no suitable
                distribution is found, and `installer` is supplied, then the result of
                calling the environment's ``obtain(req, installer)`` method will be
                returned.
        
        """
    def obtain(self, requirement, installer=None):
        """
        Obtain a distribution matching `requirement` (e.g. via download)

                Obtain a distro that matches requirement (e.g. via download).  In the
                base ``Environment`` class, this routine just returns
                ``installer(requirement)``, unless `installer` is None, in which case
                None is returned instead.  This method is a hook that allows subclasses
                to attempt other ways of obtaining a distribution before falling back
                to the `installer` argument.
        """
    def __iter__(self):
        """
        Yield the unique project names of the available distributions
        """
    def __iadd__(self, other):
        """
        In-place addition of a distribution or environment
        """
    def __add__(self, other):
        """
        Add an environment or distribution to an environment
        """
def ExtractionError(RuntimeError):
    """
    An error occurred extracting a resource

        The following attributes are available from instances of this exception:

        manager
            The resource manager that raised this exception

        cache_path
            The base directory for resource extraction

        original_error
            The exception instance that caused extraction to fail
    
    """
def ResourceManager:
    """
    Manage resource extraction and packages
    """
    def __init__(self):
        """
        Does the named resource exist?
        """
    def resource_isdir(self, package_or_requirement, resource_name):
        """
        Is the named resource an existing directory?
        """
    def resource_filename(self, package_or_requirement, resource_name):
        """
        Return a true filesystem path for specified resource
        """
    def resource_stream(self, package_or_requirement, resource_name):
        """
        Return a readable file-like object for specified resource
        """
    def resource_string(self, package_or_requirement, resource_name):
        """
        Return specified resource as a string
        """
    def resource_listdir(self, package_or_requirement, resource_name):
        """
        List the contents of the named resource directory
        """
    def extraction_error(self):
        """
        Give an error message for problems extracting file(s)
        """
    def get_cache_path(self, archive_name, names=()):
        """
        Return absolute location in cache for `archive_name` and `names`

                The parent directory of the resulting path will be created if it does
                not already exist.  `archive_name` should be the base filename of the
                enclosing egg (which may not be the name of the enclosing zipfile!),
                including its ".egg" extension.  `names`, if provided, should be a
                sequence of path name parts "under" the egg's extraction location.

                This method should only be called by resource providers that need to
                obtain an extraction location, and only for names they intend to
                extract, as it tracks the generated names for possible cleanup later.
        
        """
    def _warn_unsafe_extraction_path(path):
        """

                If the default extraction path is overridden and set to an insecure
                location, such as /tmp, it opens up an opportunity for an attacker to
                replace an extracted file with an unauthorized payload. Warn the user
                if a known insecure location is used.

                See Distribute #375 for more details.
        
        """
    def postprocess(self, tempname, filename):
        """
        Perform any platform-specific postprocessing of `tempname`

                This is where Mac header rewrites should be done; other platforms don't
                have anything special they should do.

                Resource providers should call this method ONLY after successfully
                extracting a compressed resource.  They must NOT call it on resources
                that are already in the filesystem.

                `tempname` is the current (temporary) name of the file, and `filename`
                is the name it will be renamed to by the caller after this routine
                returns.
        
        """
    def set_extraction_path(self, path):
        """
        Set the base path where resources will be extracted to, if needed.

                If you do not call this routine before any extractions take place, the
                path defaults to the return value of ``get_default_cache()``.  (Which
                is based on the ``PYTHON_EGG_CACHE`` environment variable, with various
                platform-specific fallbacks.  See that routine's documentation for more
                details.)

                Resources are extracted to subdirectories of this path based upon
                information given by the ``IResourceProvider``.  You may set this to a
                temporary directory, but then you must call ``cleanup_resources()`` to
                delete the extracted files when done.  There is no guarantee that
                ``cleanup_resources()`` will be able to remove all extracted files.

                (Note: you may not change the extraction path for a given resource
                manager once resources have been extracted, unless you first call
                ``cleanup_resources()``.)
        
        """
    def cleanup_resources(self, force=False):
        """

                Delete all extracted resource files and directories, returning a list
                of the file and directory names that could not be successfully removed.
                This function does not have any concurrency protection, so it should
                generally only be called when the extraction path is a temporary
                directory exclusive to a single process.  This method is not
                automatically called; you must call it explicitly or register it as an
                ``atexit`` function if you wish to ensure cleanup of a temporary
                directory used for extractions.
        
        """
def get_default_cache():
    """

        Return the ``PYTHON_EGG_CACHE`` environment variable
        or a platform-relevant user cache dir for an app
        named "Python-Eggs".
    
    """
def safe_name(name):
    """
    Convert an arbitrary string to a standard distribution name

        Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    
    """
def safe_version(version):
    """

        Convert an arbitrary string to a standard version string
    
    """
def safe_extra(extra):
    """
    Convert an arbitrary string to a standard 'extra' name

        Any runs of non-alphanumeric characters are replaced with a single '_',
        and the result is always lowercased.
    
    """
def to_filename(name):
    """
    Convert a project or version name to its filename-escaped form

        Any '-' characters are currently replaced with '_'.
    
    """
def invalid_marker(text):
    """

        Validate text as a PEP 508 environment marker; return an exception
        if invalid or False otherwise.
    
    """
def evaluate_marker(text, extra=None):
    """

        Evaluate a PEP 508 environment marker.
        Return a boolean indicating the marker result in this environment.
        Raise SyntaxError if marker is invalid.

        This implementation uses the 'pyparsing' module.
    
    """
def NullProvider:
    """
    Try to implement resources and metadata for arbitrary PEP 302 loaders
    """
    def __init__(self, module):
        """
        '__loader__'
        """
    def get_resource_filename(self, manager, resource_name):
        """

        """
    def get_metadata_lines(self, name):
        """
        'scripts/'
        """
    def _has(self, path):
        """
        Can't perform this operation for unregistered loader type

        """
    def _isdir(self, path):
        """
        Can't perform this operation for unregistered loader type

        """
    def _listdir(self, path):
        """
        Can't perform this operation for unregistered loader type

        """
    def _fn(self, base, resource_name):
        """
        '/'
        """
    def _validate_resource_path(path):
        """

                Validate the resource paths according to the docs.
                https://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access

                >>> warned = getfixture('recwarn')
                >>> warnings.simplefilter('always')
                >>> vrp = NullProvider._validate_resource_path
                >>> vrp('foo/bar.txt')
                >>> bool(warned)
                False
                >>> vrp('../foo/bar.txt')
                >>> bool(warned)
                True
                >>> warned.clear()
                >>> vrp('/foo/bar.txt')
                >>> bool(warned)
                True
                >>> vrp('foo/../../bar.txt')
                >>> bool(warned)
                True
                >>> warned.clear()
                >>> vrp('foo/f../bar.txt')
                >>> bool(warned)
                False

                Windows path separators are straight-up disallowed.
                >>> vrp(r'\\foo/bar.txt')
                Traceback (most recent call last):
                ...
                ValueError: Use of .. or absolute path in a resource path \
        is not allowed.

                >>> vrp(r'C:\\foo/bar.txt')
                Traceback (most recent call last):
                ...
                ValueError: Use of .. or absolute path in a resource path \
        is not allowed.

                Blank values are allowed

                >>> vrp('')
                >>> bool(warned)
                False

                Non-string values are not.

                >>> vrp(None)
                Traceback (most recent call last):
                ...
                AttributeError: ...
        
        """
    def _get(self, path):
        """
        'get_data'
        """
def EggProvider(NullProvider):
    """
    Provider based on a virtual filesystem
    """
    def __init__(self, module):
        """
         we assume here that our metadata may be nested inside a "basket
         of multiple eggs; that's why we use module_path instead of .archive

        """
def DefaultProvider(EggProvider):
    """
    Provides access to package resources in the filesystem
    """
    def _has(self, path):
        """
        'rb'
        """
    def _get(self, path):
        """
        'rb'
        """
    def _register(cls):
        """
        'SourceFileLoader'
        """
def EmptyProvider(NullProvider):
    """
    Provider that returns nothing for all requests
    """
    def _get(self, path):
        """
        ''
        """
    def _listdir(self, path):
        """

            zip manifest builder
    
        """
    def build(cls, path):
        """

                Build a dictionary similar to the zipimport directory
                caches, except instead of tuples, store ZipInfo objects.

                Use a platform-specific path separator (os.sep) for the path keys
                for compatibility with pypy on Windows.
        
        """
def MemoizedZipManifests(ZipManifests):
    """

        Memoized zipfile manifests.
    
    """
    def load(self, path):
        """

                Load a manifest at path or return a suitable manifest already loaded.
        
        """
def ZipProvider(EggProvider):
    """
    Resource support for zips and eggs
    """
    def __init__(self, module):
        """
         Convert a virtual filename (full path to file) into a zipfile subpath
         usable with the zipimport directory cache for our target archive

        """
    def _parts(self, zip_path):
        """
         Convert a zipfile subpath into an egg-relative path part list.
         pseudo-fs path

        """
    def zipinfo(self):
        """
        resource_filename() only supported for .egg, not .zip

        """
    def _get_date_and_size(zip_stat):
        """
         ymdhms+wday, yday, dst

        """
    def _extract_resource(self, manager, zip_path):
        """
         return the extracted directory name

        """
    def _is_current(self, file_path, zip_path):
        """

                Return True if the file_path is current for this zip_path
        
        """
    def _get_eager_resources(self):
        """
        'native_libs.txt'
        """
    def _index(self):
        """
        Metadata handler for standalone PKG-INFO files

            Usage::

                metadata = FileMetadata("/path/to/PKG-INFO")

            This provider rejects all data and metadata requests except for PKG-INFO,
            which is treated as existing, and will be the contents of the file at
            the provided location.
    
        """
    def __init__(self, path):
        """
        'PKG-INFO'
        """
    def get_metadata(self, name):
        """
        'PKG-INFO'
        """
    def _warn_on_replacement(self, metadata):
        """
         Python 2.7 compat for: replacement_char = 'ï¿½'

        """
    def get_metadata_lines(self, name):
        """
        Metadata provider for egg directories

            Usage::

                # Development eggs:

                egg_info = "/path/to/PackageName.egg-info"
                base_dir = os.path.dirname(egg_info)
                metadata = PathMetadata(base_dir, egg_info)
                dist_name = os.path.splitext(os.path.basename(egg_info))[0]
                dist = Distribution(basedir, project_name=dist_name, metadata=metadata)

                # Unpacked egg directories:

                egg_path = "/path/to/PackageName-ver-pyver-etc.egg"
                metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))
                dist = Distribution.from_filename(egg_path, metadata=metadata)
    
        """
    def __init__(self, path, egg_info):
        """
        Metadata provider for .egg files
        """
    def __init__(self, importer):
        """
        Create a metadata provider from a zipimporter
        """
def register_finder(importer_type, distribution_finder):
    """
    Register `distribution_finder` to find distributions in sys.path items

        `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item
        handler), and `distribution_finder` is a callable that, passed a path
        item and the importer instance, yields ``Distribution`` instances found on
        that path item.  See ``pkg_resources.find_on_path`` for an example.
    """
def find_distributions(path_item, only=False):
    """
    Yield distributions accessible via `path_item`
    """
def find_eggs_in_zip(importer, path_item, only=False):
    """

        Find eggs in zip files; possibly multiple nested eggs.
    
    """
def find_nothing(importer, path_item, only=False):
    """

        Given a list of filenames, return them in descending order
        by version number.

        >>> names = 'bar', 'foo', 'Python-2.7.10.egg', 'Python-2.7.2.egg'
        >>> _by_version_descending(names)
        ['Python-2.7.10.egg', 'Python-2.7.2.egg', 'foo', 'bar']
        >>> names = 'Setuptools-1.2.3b1.egg', 'Setuptools-1.2.3.egg'
        >>> _by_version_descending(names)
        ['Setuptools-1.2.3.egg', 'Setuptools-1.2.3b1.egg']
        >>> names = 'Setuptools-1.2.3b1.egg', 'Setuptools-1.2.3.post1.egg'
        >>> _by_version_descending(names)
        ['Setuptools-1.2.3.post1.egg', 'Setuptools-1.2.3b1.egg']
    
    """
    def _by_version(name):
        """

                Parse each component of the filename
        
        """
def find_on_path(importer, path_item, only=False):
    """
    Yield distributions accessible on a sys.path directory
    """
def dist_factory(path_item, entry, only):
    """

        Return a dist_factory for a path_item and entry
    
    """
def NoDists:
    """

        >>> bool(NoDists())
        False

        >>> list(NoDists()('anything'))
        []
    
    """
    def __bool__(self):
        """

            Attempt to list contents of path, but suppress some exceptions.
    
        """
def distributions_from_metadata(path):
    """
     empty metadata dir; skip

    """
def non_empty_lines(path):
    """

        Yield non-empty lines from file at path
    
    """
def resolve_egg_link(path):
    """

        Given a path to an .egg-link, resolve distributions
        present in the referenced path.
    
    """
def register_namespace_handler(importer_type, namespace_handler):
    """
    Register `namespace_handler` to declare namespace packages

        `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item
        handler), and `namespace_handler` is a callable like this::

            def namespace_handler(importer, path_entry, moduleName, module):
                # return a path_entry to use for child packages

        Namespace handlers are only called if the importer object has already
        agreed that it can handle the relevant path item, and they should only
        return a subpath if the module __path__ does not already contain an
        equivalent subpath.  For an example namespace handler, see
        ``pkg_resources.file_ns_handler``.
    
    """
def _handle_ns(packageName, path_item):
    """
    Ensure that named package includes a subpath of path_item (if needed)
    """
def _rebuild_mod_path(orig_path, package_name, module):
    """

        Rebuild module.__path__ ensuring that all entries are ordered
        corresponding to their sys.path order
    
    """
    def safe_sys_path_index(entry):
        """

                Workaround for #520 and #513.
        
        """
    def position_in_sys_path(path):
        """

                Return the ordinal of the path based on its position in sys.path
        
        """
def declare_namespace(packageName):
    """
    Declare that package 'packageName' is a namespace package
    """
def fixup_namespace_packages(path_item, parent=None):
    """
    Ensure that previously-declared namespace packages include path_item
    """
def file_ns_handler(importer, path_item, packageName, module):
    """
    Compute an ns-package subpath for a filesystem or zipfile importer
    """
def null_ns_handler(importer, path_item, packageName, module):
    """
    Normalize a file/dir name for comparison purposes
    """
def _cygwin_patch(filename):  # pragma: nocover
    """
     pragma: nocover
    """
def _normalize_cached(filename, _cache={}):
    """

        Determine if given path appears to be an egg.
    
    """
def _is_unpacked_egg(path):
    """

        Determine if given path appears to be an unpacked egg.
    
    """
def _set_parent_ns(packageName):
    """
    '.'
    """
def yield_lines(strs):
    """
    Yield non-empty/non-comment lines of a string or sequence
    """
def EntryPoint:
    """
    Object representing an advertised importable object
    """
    def __init__(self, name, module_name, attrs=(), extras=(), dist=None):
        """
        Invalid module name
        """
    def __str__(self):
        """
        %s = %s
        """
    def __repr__(self):
        """
        EntryPoint.parse(%r)
        """
    def load(self, require=True, *args, **kwargs):
        """

                Require packages for this EntryPoint, then resolve it.
        
        """
    def resolve(self):
        """

                Resolve the entry point from its module and attrs.
        
        """
    def require(self, env=None, installer=None):
        """
        Can't require() without a distribution
        """
    def parse(cls, src, dist=None):
        """
        Parse a single entry point from string `src`

                Entry point syntax follows the form::

                    name = some.module:some.attr [extra1, extra2]

                The entry name and module name are required, but the ``:attrs`` and
                ``[extras]`` parts are optional
        
        """
    def _parse_extras(cls, extras_spec):
        """
        'x'
        """
    def parse_group(cls, group, lines, dist=None):
        """
        Parse an entry point group
        """
    def parse_map(cls, data, dist=None):
        """
        Parse a map of entry point groups
        """
def _remove_md5_fragment(location):
    """
    ''
    """
def _version_from_file(lines):
    """

        Given an iterable of lines from a Metadata file, return
        the value of the Version field, if present, or None otherwise.
    
    """
    def is_version_line(line):
        """
        'version:'
        """
def Distribution:
    """
    Wrap an actual or potential sys.path entry w/metadata
    """
2021-03-02 20:51:28,476 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:28,476 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:28,476 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
            self, location=None, metadata=None, project_name=None,
            version=None, py_version=PY_MAJOR, platform=None,
            precedence=EGG_DIST):
        """
        'Unknown'
        """
    def from_location(cls, location, basename, metadata=None, **kw):
        """
        'name'
        """
    def _reload_version(self):
        """
        ''
        """
    def __hash__(self):
        """
         It's not a Distribution, so they are not equal

        """
    def __ne__(self, other):
        """
         These properties have to be lazy so that we don't have to load any
         metadata until/unless it's actually needed.  (i.e., some distributions
         may not know their name or version without loading PKG-INFO)


        """
    def key(self):
        """
        _parsed_version
        """
    def _warn_legacy_version(self):
        """
         While an empty version is technically a legacy version and
         is not a valid PEP 440 version, it's also unlikely to
         actually come from someone and instead it is more likely that
         it comes from setuptools attempting to parse a filename and
         including it in the list. So for that we'll gate this warning
         on if the version is anything at all or not.

        """
    def version(self):
        """
        Missing 'Version:' header and/or {} file at path: {}

        """
    def _dep_map(self):
        """

                A map of extra to its list of (direct) requirements
                for this distribution, including the null extra.
        
        """
    def _filter_extras(dm):
        """

                Given a mapping of extras to dependencies, strip off
                environment markers and filter out any dependencies
                not matching the markers.
        
        """
    def _build_dep_map(self):
        """
        'requires.txt'
        """
    def requires(self, extras=()):
        """
        List of Requirements needed for this distro if `extras` are used
        """
    def _get_metadata_path_for_display(self, name):
        """

                Return the path to the given metadata file, if available.
        
        """
    def _get_metadata(self, name):
        """
        Ensure distribution is importable on `path` (default=sys.path)
        """
    def egg_name(self):
        """
        Return what this distribution's standard .egg filename should be
        """
    def __repr__(self):
        """
        %s (%s)
        """
    def __str__(self):
        """
        'version'
        """
    def __getattr__(self, attr):
        """
        Delegate all unrecognized public attributes to .metadata provider
        """
    def __dir__(self):
        """
        '_'
        """
    def from_filename(cls, filename, metadata=None, **kw):
        """
        Return a ``Requirement`` that matches this distribution exactly
        """
    def load_entry_point(self, group, name):
        """
        Return the `name` entry point of `group` or raise ImportError
        """
    def get_entry_map(self, group=None):
        """
        Return the entry point map for `group`, or the full entry map
        """
    def get_entry_info(self, group, name):
        """
        Return the EntryPoint object for `group`+`name`, or ``None``
        """
    def insert_on(self, path, loc=None, replace=False):
        """
        Ensure self.location is on path

                If replace=False (default):
                    - If location is already in path anywhere, do nothing.
                    - Else:
                      - If it's an egg and its parent directory is on path,
                        insert just ahead of the parent.
                      - Else: add to the end of path.
                If replace=True:
                    - If location is already on path anywhere (not eggs)
                      or higher priority than its parent (eggs)
                      do nothing.
                    - Else:
                      - If it's an egg and its parent directory is on path,
                        insert just ahead of the parent,
                        removing any lower-priority entries.
                      - Else: add it to the front of path.
        
        """
    def check_version_conflict(self):
        """
        'setuptools'
        """
    def has_version(self):
        """
        Unbuilt egg for 
        """
    def clone(self, **kw):
        """
        Copy this distribution, substituting in any changed keyword args
        """
    def extras(self):
        """

                Packages installed by distutils (e.g. numpy or scipy),
                which uses an old safe_version, and so
                their version numbers can get mangled when
                converted to filenames (e.g., 1.11.0.dev0+2329eae to
                1.11.0.dev0_2329eae). These distributions will not be
                parsed properly
                downstream by Distribution and safe_version, so
                take an extra step and try to get the version number from
                the metadata file itself instead of the filename.
        
        """
def DistInfoDistribution(Distribution):
    """

        Wrap an actual or potential sys.path entry
        w/metadata, .dist-info style.
    
    """
    def _parsed_pkg_info(self):
        """
        Parse and cache metadata
        """
    def _dep_map(self):
        """
        Recompute this distribution's dependencies.
        """
        def reqs_for_extra(extra):
            """
            'extra'
            """
def issue_warning(*args, **kw):
    """
     find the first stack frame that is *not* code in
     the pkg_resources module, to use for the warning

    """
def RequirementParseError(ValueError):
    """
    ' '
    """
def parse_requirements(strs):
    """
    Yield ``Requirement`` objects for each specification in `strs`

        `strs` must be a string, or a (possibly-nested) iterable thereof.
    
    """
def Requirement(packaging.requirements.Requirement):
    """
    DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!
    """
    def __eq__(self, other):
        """
         Allow prereleases always in order to match the previous behavior of
         this method. In the future this should be smarter and follow PEP 440
         more accurately.

        """
    def __hash__(self):
        """
        Requirement.parse(%r)
        """
    def parse(s):
        """

            Ensure object appears in the mro even
            for old-style classes.
    
        """
def _find_adapter(registry, ob):
    """
    Return an adapter factory for `ob` from `registry`
    """
def ensure_directory(path):
    """
    Ensure that the parent directory of `path` exists
    """
def _bypass_ensure_directory(path):
    """
    Sandbox-bypassing version of ensure_directory()
    """
def split_sections(s):
    """
    Split a string or iterable thereof into (section, content) pairs

        Each ``section`` is a stripped version of the section header ("[section]")
        and each ``content`` is a list of stripped lines excluding blank lines and
        comment-only lines.  If there are any such lines before the first section
        header, they're returned in a first ``section`` of ``None``.
    
    """
def _mkstemp(*args, **kw):
    """
     temporarily bypass sandboxing

    """
def _call_aside(f, *args, **kwargs):
    """
    Set up global resource manager (deliberately not state-saved)
    """
def _initialize_master_working_set():
    """

        Prepare the master working set and make the ``require()``
        API available.

        This function has explicit effects on the global state
        of pkg_resources. It is intended to be invoked once at
        the initialization of this module.

        Invocation by other packages is unsupported and done
        at their own risk.
    
    """
def PkgResourcesDeprecationWarning(Warning):
    """

        Base class for warning about deprecations in ``pkg_resources``

        This class is not derived from ``DeprecationWarning``, and as such is
        visible by default.
    
    """
